<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Java核心笔记 | Bay·Blog</title>
<meta name="description" content="一个小站">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://baoanyu.github.io/favicon.ico?v=1722838949542">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://baoanyu.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  

<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://baoanyu.github.io">Bay·Blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                归档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
          <li>
            
              <a href="/post/about" class="menu">
                关于
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Java核心笔记</h1>
            <p class="article-meta">
              2022-07-28
              
                <a href="https://baoanyu.github.io/tag/mj5T-ObLsk/" class="badge ">
                  Java-becomes-god
                </a>
              
            </p>
            
            <div class="post-content" v-pre>
              <h4 id="多态多态polymorphism指为不同数据类型的实体提供统一的接口或使用一个单一的符号来表示多个不同的类型">多态（多态（Polymorphism）,指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型）</h4>
<ul>
<li>
<p>多态的类别（特设多态，参数多态，字类型）</p>
<ul>
<li>
<p>特设多态</p>
<p>函数重载，运算符重载</p>
</li>
<li>
<p>参数多态</p>
<p>泛型，函数式编程</p>
</li>
<li>
<p>子类型</p>
<p>在面向对象程序设计中，计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。</p>
</li>
</ul>
</li>
</ul>
<h3 id="java的继承与实现">Java的继承与实现</h3>
<ul>
<li>
<p>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要<em><strong>复用</strong></em>，而实现的根本原因是需要定义一个<em><strong>标准</strong></em>。</p>
<p>! <em>特别需要注意的是，Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。</em> 但是这个问题在Java 8之后也不绝对了</p>
<p>! 在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8以前），这就避免了 C++ 中多继承的歧义问题。</p>
</li>
</ul>
<h3 id="java的继承和组合">Java的继承和组合</h3>
<ul>
<li>
<p>作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式</p>
</li>
<li>
<p><strong>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况</strong>。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。《<a href="">Java编程思想</a>》</p>
<p>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在<a href="https://zh.wikipedia.org/wiki/Is-a"><code>is-a</code></a>关系的时候，类B才应该继承类A。《<a href="">Effective Java</a>》</p>
</li>
<li>
<table>
<thead>
<tr>
<th>组 合 关 系</th>
<th>继 承 关 系</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</td>
<td>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</td>
</tr>
<tr>
<td>优点：具有较好的可扩展性</td>
<td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td>
</tr>
<tr>
<td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td>
<td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td>
</tr>
<tr>
<td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td>
<td>缺点：子类不能改变父类的接口</td>
</tr>
<tr>
<td>缺点：整体类不能自动获得和局部类同样的接口</td>
<td>优点：子类能自动继承父类的接口</td>
</tr>
<tr>
<td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td>
<td>优点：创建子类的对象时，无须创建父类的对象</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="类变量-成员变量和局部变量">类变量、成员变量和局部变量</h3>
<ul>
<li>
<p>Java中共有三种变量，分别是<strong>类变量、成员变量和局部变量</strong>。他们分别存放在<strong>JVM的方法区、堆内存和栈内存</strong>中。</p>
</li>
<li>
<pre><code class="language-java">    /**
     * @author Hollis
     */
    public class Variables {
    
        /**
         * 类变量
         */
        private static int a;
    
        /**
         * 成员变量
         */
        private int b;
    
        /**
         * 局部变量
         * @param c
         */
        public void test(int c){
            int d;
        }
    }
</code></pre>
</li>
</ul>
<ul>
<li>
<p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p>
<p>a作为类变量，他存放在方法区中；b作为成员变量，和对象一起存储在堆内存中（不考虑栈上分配的情况）；c和d作为方法的局部变量，保存在栈内存中。</p>
<p>之所以要在这一章节重点介绍下这三种变量类型，是因为很多人因为不知道这三种类型的区别，所以不知道他们分别存放在哪里，这就导致不知道那些变量需要考虑并发问题。</p>
<p>这里先简单说明一下：</p>
<p><strong>因为只有共享变量才会遇到并发问题，所以，变量a和b是共享变量，变量c和d是非共享变量。所以如果遇到多线程场景，对于变量a和b的操作是需要考虑线程安全的，而对于线程c和d的操作是不需要考虑线程安全的。</strong></p>
</li>
</ul>
<h3 id="值传递与引用传递"><em>值传递与引用传递</em></h3>
<ul>
<li>值传递-复制</li>
<li>引用传递-直接</li>
</ul>
<h3 id="bio-nio和aio的区别-三种io的用法与原理">BIO、NIO和AIO的区别、三种IO的用法与原理</h3>
<h3 id="io">IO</h3>
<p>什么是IO? 它是指计算机与外部世界或者一个程序与计算机的其余部分之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p>
<p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p>
<h3 id="bio">BIO</h3>
<p>Java BIO即Block I/O ， 同步并阻塞的IO。</p>
<p>BIO就是传统的java.io包下面的代码实现。</p>
<h3 id="nio">NIO</h3>
<p>什么是NIO? NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<h3 id="aio">AIO</h3>
<p>Java AIO即Async非阻塞，是异步非阻塞的IO。</p>
<h3 id="区别及联系">区别及联系</h3>
<p>BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。</p>
<p>NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断地轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。</p>
<p>AIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。</p>
<h3 id="各自适用场景">各自适用场景</h3>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h3 id="使用方式">使用方式</h3>
<h4 id="使用bio实现文件的读取和写入">使用BIO实现文件的读取和写入。</h4>
<pre><code class="language-java">       //Initializes The Object
        User1 user = new User1();
        user.setName(&quot;hollis&quot;);
        user.setAge(23);
        System.out.println(user);

        //Write Obj to File
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;));
            oos.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(oos);
        }

        //Read Obj from File
        File file = new File(&quot;tempFile&quot;);
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(file));
            User1 newUser = (User1) ois.readObject();
            System.out.println(newUser);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(ois);
            try {
                FileUtils.forceDelete(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
复制ErrorOK!
</code></pre>
<h4 id="使用nio实现文件的读取和写入"><a href="https://hollischuang.github.io/toBeTopJavaer/#/basics/java-basic/bio-vs-nio-vs-aio?id=%E4%BD%BF%E7%94%A8nio%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E3%80%82">使用NIO实现文件的读取和写入。</a></h4>
<pre><code class="language-java">static void readNIO() {
        String pathname = &quot;C:\\Users\\adew\\Desktop\\jd-gui.cfg&quot;;
        FileInputStream fin = null;
        try {
            fin = new FileInputStream(new File(pathname));
            FileChannel channel = fin.getChannel();

            int capacity = 100;// 字节
            ByteBuffer bf = ByteBuffer.allocate(capacity);
            System.out.println(&quot;限制是：&quot; + bf.limit() + &quot;容量是：&quot; + bf.capacity()
                    + &quot;位置是：&quot; + bf.position());
            int length = -1;

            while ((length = channel.read(bf)) != -1) {

                /*
                 * 注意，读取后，将位置置为0，将limit置为容量, 以备下次读入到字节缓冲中，从0开始存储
                 */
                bf.clear();
                byte[] bytes = bf.array();
                System.out.write(bytes, 0, length);
                System.out.println();

                System.out.println(&quot;限制是：&quot; + bf.limit() + &quot;容量是：&quot; + bf.capacity()
                        + &quot;位置是：&quot; + bf.position());

            }

            channel.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fin != null) {
                try {
                    fin.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static void writeNIO() {
        String filename = &quot;out.txt&quot;;
        FileOutputStream fos = null;
        try {

            fos = new FileOutputStream(new File(filename));
            FileChannel channel = fos.getChannel();
            ByteBuffer src = Charset.forName(&quot;utf8&quot;).encode(&quot;你好你好你好你好你好&quot;);
            // 字节缓冲的容量和limit会随着数据长度变化，不是固定不变的
            System.out.println(&quot;初始化容量和limit：&quot; + src.capacity() + &quot;,&quot;
                    + src.limit());
            int length = 0;

            while ((length = channel.write(src)) != 0) {
                /*
                 * 注意，这里不需要clear，将缓冲中的数据写入到通道中后 第二次接着上一次的顺序往下读
                 */
                System.out.println(&quot;写入长度:&quot; + length);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
复制ErrorOK!
</code></pre>
<h4 id="使用aio实现文件的读取和写入">使用AIO实现文件的读取和写入</h4>
<p>public class ReadFromFile {<br>
public static void main(String[] args) throws Exception {<br>
Path file = Paths.get(&quot;/usr/a.txt&quot;);<br>
AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(100_000);
Future&lt;Integer&gt; result = channel.read(buffer, 0);

while (!result.isDone()) {
  ProfitCalculator.calculateTax();
}
Integer bytesRead = result.get();
System.out.println(&quot;Bytes read [&quot; + bytesRead + &quot;]&quot;);
</code></pre>
<p>}<br>
}<br>
class ProfitCalculator {<br>
public ProfitCalculator() {<br>
}<br>
public static void calculateTax() {<br>
}<br>
}</p>
<p>public class WriteToFile {</p>
<p>public static void main(String[] args) throws Exception {<br>
AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(<br>
Paths.get(&quot;/asynchronous.txt&quot;), StandardOpenOption.READ,<br>
StandardOpenOption.WRITE, StandardOpenOption.CREATE);<br>
CompletionHandler&lt;Integer, Object&gt; handler = new CompletionHandler&lt;Integer, Object&gt;() {</p>
<pre><code>  @Override
  public void completed(Integer result, Object attachment) {
    System.out.println(&quot;Attachment: &quot; + attachment + &quot; &quot; + result
        + &quot; bytes written&quot;);
    System.out.println(&quot;CompletionHandler Thread ID: &quot;
        + Thread.currentThread().getId());
  }

  @Override
  public void failed(Throwable e, Object attachment) {
    System.err.println(&quot;Attachment: &quot; + attachment + &quot; failed with:&quot;);
    e.printStackTrace();
  }
};

System.out.println(&quot;Main Thread ID: &quot; + Thread.currentThread().getId());
fileChannel.write(ByteBuffer.wrap(&quot;Sample&quot;.getBytes()), 0, &quot;First Write&quot;,
    handler);
fileChannel.write(ByteBuffer.wrap(&quot;Box&quot;.getBytes()), 0, &quot;Second Write&quot;,
    handler);
</code></pre>
<p>}<br>
}</p>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://baoanyu.github.io/post/stringbuffer-he-stringbuilder-de-qu-bie/">
                <h3 class="post-title">
                   StringBuffer和StringBuilder 的区别
                </h3>
              </a>
            </div>
          
        </div>
        
          
            <div class="paper" data-aos="fade-in">
              <div id="gitalk-container"></div>
            </div>
          

          
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://baoanyu.github.io/images/avatar.png?v=1722838949542" class="no-responsive avatar">
    <div class="text-muted">一个小站</div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://baoanyu.github.io/post/springCloud/">SpringCloud Alibaba Nacos 组件</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/mac-yi-xie-chang-yong-ming-ling/">Mac一些常用命令</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/java8-sheng-ji-java11-de-ji-lu/">Java8升级到Java11，记录每个Java版本的重要特性</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/ghCv50O5k/">技术问题第一期MySQL（2023.2.17）</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/auGSOk7NJ/">技术宝典第一期MySQL（2023.2.17）</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/LwP2-SWQ_/">工作总结（2022.10.19更新）</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/ben-di-an-zhuang-centos-xu-ni-ji-da-jian-ben-di-ao-si-ting-gitee-kai-yuan-xiang-mu-austinkai-fa-huan-jing-shou-ce/">本地安装centos虚拟机搭建本地奥斯汀(Gitee 开源项目Austin)开发环境手册TODO</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/sping-boot-bian-xie-yi-bu-zhi-xing-fang-fa/">Sping boot 编写异步执行方法</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/docker-chang-yong-ming-ling/">Docker常用命令</a>
            </li>
          
        
          
            <li>
              <a href="https://baoanyu.github.io/post/git-la-qu-dai-ma-ben-di-you-geng-xin-chong-tu-zen-me-ban/">Git拉取代码，本地有更新冲突怎么办</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://baoanyu.github.io/tag/dTGX-MDDZ/" class="badge secondary">
          Java
        </a>
      
        <a href="https://baoanyu.github.io/tag/1T284W0ZQ_/" class="badge success">
          Other
        </a>
      
        <a href="https://baoanyu.github.io/tag/zvL9-2Vab/" class="badge ">
          面试问题
        </a>
      
        <a href="https://baoanyu.github.io/tag/6l6DUeQ-fz/" class="badge warning">
          面试技术
        </a>
      
        <a href="https://baoanyu.github.io/tag/nCjir3oS8y/" class="badge secondary">
          Works
        </a>
      
        <a href="https://baoanyu.github.io/tag/mj5T-ObLsk/" class="badge success">
          Java-becomes-god
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/dashboard" target="_blank">GitHub</a> | <a class="rss" href="https://baoanyu.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'd515ce026268c048b297',
        clientSecret: '3ccc2fab73e936d1adcb0c3330ebeb12e8f21fec',
        repo: 'baoanyu.github.io',
        owner: 'baoanyu',
        admin: ['baoanyu'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
